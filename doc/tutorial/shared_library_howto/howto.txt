
Compiling and Using Theano Functions as Shared Libraries
========================================================

..note:

  This functionality is experimental. Not every feature works and 
  some may break in unexpected ways or behave differently.


This functionality was only tested on CPU code on a Linux machine.

For now shared variables are not supported.

Every node of a function that you want to use as a shared library must
have a C implementation.
 
To compile a function as shared library, you must use CLinker with the the
parameter c_callable=True:

 linker = theano.gof.CLinker(c_callable=True)
 mode = theano.Mode(linker=linker)
 f = theano.function(inputs, outputs , mode=mode)

The shared library is built in a  specific temporary directory, in the Theano 
cache directory. The name of the directory is stored in the filename 
property of the function. 

 print f.fn.filename

In this directory you will find the .so library, the header file, 
a makefile and an exe.cpp which can be used as template 
to build your application. There is also
a exec.h in which you find the command used to build the library.

Let's walk through an example to see how to use the shared library.

Build the shared library for the function in function.py:

 python function.py

The outputs show you where Theano puts the library. To see if everything
works correctly go in that directory and launch the exec executable. 
You should get

 After import numpy (hexvalue)
 after import_array1()
 after cinit()
 run() from the shared library returned=0
 [[  0.   2.   4.   6.]
 [  8.  10.  12.  14.]
 [ 16.  18.  20.  22.]]
 [ 20.  23.  26.  29.]
 main end, before Py_Finalize

..note:

  In general case, the program can give some errors for generic
  functions because itmakes some assumptions on the data the can be wrong. 
  Take it as a simple template. 

Theano compiles the function as a C++ class with variables mapped to internal
variables. To run the function you initialize the class calling the cinit
function, then pass the values of inputs variables as numpy arrays and call the
run method. If there are no errors you can get the outputs values from the 
C++ class members.
The C++ class members must be set and get using the PyList_SetItem and
PyList_GET_ITEM respectively.

In the exec.cpp file you will find after the includes a comment with the
mapping between theano inputs, outputs and C++ class members.
In program main function, Python is initialized and numpy is imported. 
Then the theano library is initialized with a call to cinit(). 
After that, in this example program, there is the definition of 
two numpy arrays and they are set as function inputs.
Then the runmethod is called and the outputs values are returned 
if there are no errors.

One thing you can do to better understand how the code work is to change the
inputs values. As an example you can delete from line 35 to 52 
and substitute them with:

 npy_intp dims[2]={2,5};
 PyObject* V7=PyArray_SimpleNew(2,dims,NPY_FLOAT64);
 npy_float64 *V7_ptr =(npy_float64 *)PyArray_DATA((PyArrayObject*)V7);
 for(int i=0; i<10; i++)
      V7_ptr[i]=i;
 
 PyList_SetItem(struct_ptr->storage_V7, 0, V7);
  
 npy_intp dims2[1]={2};
 PyObject* V13=PyArray_SimpleNew(1,dims2,NPY_FLOAT64);
 npy_float64 *V13_ptr =(npy_float64 *)PyArray_DATA((PyArrayObject*)V13);
 for(int i=0; i<2; i++)
      V13_ptr[i]=i;        

 PyList_SetItem(struct_ptr->storage_V13, 0, V13);

Now x is a 2x5 matrix with all entries equal to one, and y is [1,2]. Now you
can recompile exec with 

 make exec

There are differents way to intialize numpy vectors with yours values, using numpy C api (http://docs.scipy.org/doc/numpy/reference/c-api.html) or using something like BoostNumpy (https://github.com/ndarray/Boost.NumPy).
